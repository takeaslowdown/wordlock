local function fmt_input(input)
	local out = ''
	utf8.gsub(input, ".", function(c)
		out = out .. c .. ' '
	end)

	return out
end

function init(self)
	self.velocity = vmath.vector3()
	go.property("hp", 1)
	go.property("current_spell", '')
	
	self.being_attacked = false
	self.stunned = false
	self.state = 0
	-- reserved states are
	-- 0 - do nothing, think what to do :\
	-- 1 - move /\
	-- 2 - cast atk spell ->
	-- 3 - cast barrier (:)

	label.set_text("#spell", fmt_input(""))
	self.spellfactory = "#spellfactory"
	go.property("barrier", false)
end

local function able_to_action(self)
	return not self.stunned and not self.being_attacked
end

local function play_animation(self, anim)
	if self.anim ~= anim then
		sprite.play_flipbook("#sprite", anim)
		self.anim = anim
	end
end

local function decise(self, dt)
	-- debug
	-- if true then
	-- 	return 2
	-- end
	
	local n = math.random(0, 1000)
	
	if n % 3 == 0 then
		return 2
	elseif n % 7 == 0 then
		return 3
	elseif n % 13 == 0 then
		return 4
	else
		return 1
	end
end

local function sign(val)
	if val < 0 then
		return -1
	else
		return 1
	end
end

local function cast_spell(self, spell)
	self.current_spell = spell
	label.set_text("#spell", fmt_input(self.current_spell))
end

local function reset_state(self)
	self.state = 0
	self.velocity.x = 0
	label.set_text("#spell", "")
	play_animation(self, "idle")
	self.barrier = false
	self.being_attacked = false
end

local function stun_for(self, time)
	self.stunned = true
	play_animation(self, "stun")
	label.set_text("#spell", "оглушен!")
	timer.delay(time, false, function() play_animation(self, "idle"); self.stunned = false; reset_state(self); end)
end

local function apply_state(self)
	local state_time = 1.0 -- in seconds
	if self.state == 0 then
		state_time = 0.001
	elseif self.state == 1 then
		local sign = sign(math.random(0, 10) - 5)
		self.velocity.x = 50 * sign
		state_time = 1.0
		play_animation(self, "walk");
	elseif self.state == 2 then
		cast_spell(self, "стрела")
		play_animation(self, "cast")
		state_time = 2

		local p = go.get_position("#")
		local dir = go.get_position("/player/player#player") - go.get_position("#")
		p.x = p.x + 25 * sign(dir.x)
		p.y = p.y + 35
		p.z = -1
		local props = {}
		props[hash("/spell")] = {projectile = sign(dir.x), dmg = 1.0, by_player = false}
		timer.delay(state_time, false, function() if able_to_action(self) then collectionfactory.create(self.spellfactory, p, vmath.quat(), props, 1.0)  end; end)
	elseif self.state == 3 then
		cast_spell(self, "барьер")
		play_animation(self, "cast")
		state_time = 7.5
		timer.delay(state_time / 2, false, function() if able_to_action(self) then play_animation(self, "barrier"); self.barrier = true; self.current_spell = ""; end; end)
	elseif self.state == 4 then
		cast_spell(self, "безвременье")
		state_time = 3.0
		timer.delay(state_time, false, function() msg.post("/player/bg", "disable"); end)
		timer.delay(state_time * 3, false, function() msg.post("/player/bg", "enable"); end)
	end

	timer.delay(state_time, false, function() if able_to_action(self) then reset_state(self); end; end)
end

function update(self, dt)
	if self.state == 0 and not self.being_attacked then
		self.state = decise(self, dt)
		apply_state(self)
	end
end

function fixed_update(self, dt)
	if self.hp == 0 then
		go.delete(".")
	end

	if not able_to_action(self) then
		return
	end

	local pos = go.get_position(".")
	self.velocity.y = self.velocity.y - 100 * dt
	pos = pos + self.velocity * dt
	go.set_position(pos)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("get_dmg") then
		if self.barrier then
			return
		end
		if not self.being_attacked then
			print('got dmg from ' .. sender)
			self.being_attacked = true
			self.hp = self.hp - go.get(sender, "dmg")
			play_animation(self, "stun")
			timer.delay(0.5, false, function() reset_state(self); end)
		end
	elseif message_id == hash("counterspell") then
		print(go.get(sender, "inputhash"))
		if not self.stunned and go.get(sender, "inputhash") == hash("контр" .. self.current_spell) then
			stun_for(self, 2.0)
		end
	end
end